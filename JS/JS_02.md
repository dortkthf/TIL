# ECMA Script

### 코딩 스타일 가이드

- 코딩 스타일의 핵심은 합의된 원칙과 일관성

  - 절대적인 하나의 정답은 없으며, 상황에 맞게 원칙을 정하고 일관성 있게 사용하는 것이 중요

- 코딩 스타일은 코드의 품질에 직결되는 중요한 요소

  - 코드의 가독성, 유지보수 또는 팀원과의 커뮤니케이션 등 개발 과정 전체에 영향을 끼침

- 다양한 자바스크립트 코딩 스타일 가이드

  - [Airbnb Javascript Style Guide](https://github.com/airbnb/javascript)

  - [Google Javascript Style Guide](https://google.github.io/styleguide/jsguide.html)
  - [standardjs](https://standardjs.com/#javascript-style-guide-linter-and-formatter)

# 변수와 식별자

- 식별자(identifier)는 변수를 구분할 수 있는 변수명을 말함
- 식별자는 반드시 문자, 달러($) 또는 밑줄(_)로 시작
- 대소문자를 구분하며, 클래스명 외에는 모두 소문자로 시작
- 예약어* 사용 불가능
  - 예약어 예시: for, if, function 등
- (참고) 선언, 할당, 초기화
- 선언(Declaration)
  - 변수를 생성하는 행위 또는 시점
- 할당(Assignment)
  - 선언된 변수에 값을 저장하는 행위 또는 시점
- 초기화(Initializtion)
  - 선언된 변수에 처음으로 값을 저장하는 행위 또는 시점

```js
//선언

let foo
console.log(foo)

//할당

foo = 11
console.log(foo)

//선언+할당

let bar = 0
console.log(bar)
```

### let, const // 재할당

```js
// let (재할당 가능)
let number = 10 // 선언 및 초기값 할당
number = 10 // 재할당

console.log(number) // 10

// const (재할당 불가능)
const number = 10 // 선언 및 초기값 할당
number = 10 // 재할당 불가능

```

### let, const // 재선언

```js
// let (재선언 불가능)
let number = 10 // 선언 및 초기값 할당
let number = 50 // 재선언 불가능

//const (재선언 불가능)
const number = 10 // 선언 및 초기값 할당
const number = 50 // 재선언 불가능
```

### let, const (블록 스코프)

- 블록 스코프*(block scope)

  - if, for, 함수 등의 중괄호 내부를 가리킴

  - 블록 스코프를 가지는 변수는

    블록 바깥에서 접근 불가능

```js
let x = 1
if (x===1) {
    let x = 2
    console.log(x) // 2
}
console.log(x) // 1
```



### var

- var 로 선언한 변수는 재선언 및 재할당 모두 가능
- ES6 이전에 변수를 선언할 때 사용되던 키워드
- 호이스팅* 되는 특성으로 인해 예기치 못한 문제 발생 가능
  - 따라서 ES6 이후부터는 var 대신 const와 let을 사용하는 것을 권장

```js
var number = 10 // 선언 및 초기값 할당
var number = 50 // 재할당
console.log(number) // 50
```

- 함수 스코프*
  - 함수의 중괄호 내부를 가리킴
  - 함수 스코프를 가지는 변수는 함수 바깥에서 접근 불가능

```js
function foo() {
    var x = 5
    console.log(x) // 5
}
// ReferenceError: x is not defined
console.log(x)
```

### 호이스팅

- 호이스팅(hoisting)
  - 변수를 선언 이전에 참조할 수 있는 현상
  - 변수 선언 이전의 위치에서 접근 시 undefined를 반환
- JS는 모든 선언을 호이스팅한다.
- 즉 var, let, const 모두 호ㅇ스팅이 발생하지만, var는 선언과 초기화가 동시에 발생하여 일시적 사각지대가 존재하지 않는다.

```js
console.log(username) // undefined
var username = '홍길동'

console.log(email) // Uncaught ReferenceError
let email = 'gildong@gmail.com'

console.log(age) // Uncaught ReferenceError
const age = 50
```

### let, const, var 비교

| 키워드 | 재선언 | 재할당 |   스코프    |     비고      |
| :----: | :----: | :----: | :---------: | :-----------: |
|  let   |   X    |   O    | 블록 스코프 | ES6 부터 도입 |
| const  |   X    |   X    | 블록 스코프 | ES6 부터 도입 |
|  var   |   O    |   O    | 함수 스코프 |    사용 X     |

# 데이터 타입

- JS의 모든 값은 특정한 데이터 다입을 가짐
- 크게 원시 타입(Primative type)과 참조 타입(Reference type)으로 분류됨

### 원시 타입 (Primitive type)

- 객체 (object)가 아닌 기본 타입
- 변수에 해당 타입의 값이 담김
- 다른 변수에 복사할 때 실제 값이 복사됨

```js
let message = '안녕하세요' // message 선언 및 할당

let greeting = message // greeting에 message 복사
console.log(greeting) // '안녕하세요!' 출력

message = 'Hello, world!' // message 재할당
console.log(greeting) // '안녕하세요!' 출력

// 즉 원시 타입은 실제 해당 타입의 값을 변수에 저장한다.
```

### 참조 타입 (Reference type)

- 개체 타입의 자료형
- 변수에 해당 객체의 참조 값이 담김
- 다른 변수에 복사할 때 참조 값이 복사됨

```js
const message = ['안녕하세요'] // message 선언 및 할당

const greeting = message // greeting에 message 복사
console.log(greeting) // ['안녕하세요!'] 출력

message[0] = 'Hello world!' // message 재할당
console.log(greeting) // ['Hello world!'] 출력

// 참조 타입은 해당 객체를 참조할 수 있는 참조 값을 저장한다.
```

### 숫자(Number) 타입

- 정수, 실수 구분 없는 하나의 숫자 타입
- 부동소수점 형식을 따름
- (참고) NaN (Not-A-Number)
  - 계산 불가능한 경우 반환되는 값
    - ex) 'Angel' / 1004 => NaN

```js
const a = 13 // 양의 정수
const b = -5 // 음의 정수
const c = 3.14 // 실수
const d = 2.998e8 // 거듭제곱
const e = Infinity // 양의 무한대
const f = -Infinity // 음의 무한대
const g = NaN // 산술 연산 불가
```

### 문자열 타입

- 텍스트 데이터를 나타내는 타입
- 16비트 유니코드 문자의 집합
- 작은따옴표 또는 큰따옴표 모두 가능
- 템플릿 리터럴
  - ES6부터 지원
  - 따옴표 대신 backtick(``)으로 표현
  - ${expression} 형태로 표현식 삽입 가능

```js
const firstName = 'Brandan'
const lasName = 'Eich'
const fullName = `${firstName} ${lastName}`

console.log(fullName) // Brandan Eich
```

### undefined

- 변수의 값이 없음을 나타내는 데이터 타입
- 변수 선언 이후 직접 값을 할당하지 않으면, 자동으로 undefined가 할당됨

```js
let firstName
console.log(firstName) // undefined
```

### null

- 변수의 값이 없음을 의도적으로 표현할 때 사용하는 데이터 타입

- (참고) null 타입과 typeof 연산자*

  - typeof 연산자* : 자료형 평가를 위한 연산자

  - null 타입은 ECMA 명세의 원시 타입의 정의에 따라 원시 타입에 속하지만,

    typeof 연산자의 결과는 객체(object)로 표현됨

```js
let firstName = null
console.log(firstName) // null

typeof null // object
```

### Boolean 타입

- 논리적 참 또는 거짓을 나타내는 타입
- true 또는 false로 표현
- 조건문 또는 반복문*에서 유용하게 사용
  - 조건문 또는 반복문에서 boolean이 아닌 데이터 타입은 자동 형변환 규칙에 따라 true 또는 false로 변환됨

```js
let isAdmin = true
console.log(isAdmin) // true

isAdmin = false
console.log(isAdmin) // false
```

